from typing import Sequence, Literal


class AlignmentOperation: ...


class Match(AlignmentOperation):
    def __new__(cls) -> Match: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Match) -> bool: ...
    def __ne__(self, other: Match) -> bool: ...
    def __repr__(self) -> str: ...


class Subst(AlignmentOperation):
    def __new__(cls) -> Subst: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Subst) -> bool: ...
    def __ne__(self, other: Subst) -> bool: ...
    def __repr__(self) -> str: ...


class Del(AlignmentOperation):
    def __new__(cls) -> Del: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Del) -> bool: ...
    def __ne__(self, other: Del) -> bool: ...
    def __repr__(self) -> str: ...


class Ins(AlignmentOperation):
    def __new__(cls) -> Ins: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Ins) -> bool: ...
    def __ne__(self, other: Ins) -> bool: ...
    def __repr__(self) -> str: ...


class Xclip(AlignmentOperation):
    def __new__(cls, x: int) -> Xclip: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Xclip) -> bool: ...
    def __ne__(self, other: Xclip) -> bool: ...
    def __repr__(self) -> str: ...


class Yclip(AlignmentOperation):
    def __new__(cls, y: int) -> Yclip: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Yclip) -> bool: ...
    def __ne__(self, other: Yclip) -> bool: ...
    def __repr__(self) -> str: ...


class Alignment:
    def __new__(
            cls,
            score: int,
            x_start: int,
            y_start: int,
            x_end: int,
            y_end: int,
            x_len: int,
            y_len: int,
            operations: Sequence[AlignmentOperation],
            mode: Literal['local', 'semiglobal', 'global', 'custom'] = 'global',
    ) -> Alignment: ...
    def __repr__(self) -> str: ...
    def cigar(self, hard_clip: bool) -> str: ...
    def pretty(self, x: bytes, y: bytes) -> str: ...
    def path(self) -> tuple[int, int, AlignmentOperation]: ...
    @property
    def score(self) -> int: ...
    @property
    def x_start(self) -> int: ...
    @property
    def y_start(self) -> int: ...
    @property
    def x_end(self) -> int: ...
    @property
    def y_end(self) -> int: ...
    @property
    def x_len(self) -> int: ...
    @property
    def y_len(self) -> int: ...
    @property
    def operations(self) -> Sequence[AlignmentOperation]: ...
    @property
    def mode(self) -> str: ...


class Scoring:
    def __new__(
            cls,
            gap_open: int,
            gap_extend: int,
            match_func: Literal['blosum62', 'pam120', 'pam200', 'pam250', 'pam40'],
    ) -> Scoring: ...
    @classmethod
    def from_scores(cls, gap_open: int, gap_extend: int, match_score: int, mismatch_score: int) -> Scoring: ...


DEFAULT_ALIGNER_CAPACITY: int


class PairwiseAligner:
    def __new__(
            cls,
            scoring: Scoring,
            m: int = DEFAULT_ALIGNER_CAPACITY,
            n: int = DEFAULT_ALIGNER_CAPACITY,
    ) -> PairwiseAligner: ...
    def custom(self, x: bytes, y: bytes) -> Alignment: ...
    def semiglobal(self, x: bytes, y: bytes) -> Alignment: ...
    def local(self, x: bytes, y: bytes) -> Alignment: ...
